module Matchy;

%%{
#include <matchy/matchy.h>
#include <zeek/Val.h>
#include "Plugin.h"

using namespace matchy;
using namespace zeek::plugin::Matchy;
%%}

## Load a Matchy database from file. Returns an opaque database handle.
##
## filename: Path to the .mxy database file
##
## Returns: Opaque database handle, or nil on failure
function load_database%(filename: string%): opaque of MatchyDB
%{
    const char* path = filename->CheckString();
    
    // Open database
    matchy::matchy_t* db = matchy_open(path);
    if (!db) {
        zeek::reporter->Warning("Failed to open Matchy database: %s", path);
        return nullptr;
    }
    
    // Wrap in opaque type
    return zeek::make_intrusive<MatchyDB>(db);
%}

## Check if a database handle is valid.
##
## db: Database handle from load_database()
##
## Returns: true if handle is valid and database is open, false otherwise
function is_valid%(db: opaque of MatchyDB%): bool
%{
    if (!db) {
        return zeek::val_mgr->False();
    }
    
    auto* db_val = static_cast<MatchyDB*>(db->AsOpaqueVal());
    if (!db_val || !db_val->GetHandle()) {
        return zeek::val_mgr->False();
    }
    
    return zeek::val_mgr->True();
%}

## Query database by string (exact match or pattern). Returns JSON string with results.
##
## db: Database handle from load_database()
## query: String to query (domain name, exact string, or pattern)
##
## Returns: JSON string with match data, or empty string if no match
function query_string%(db: opaque of MatchyDB, query: string%): string
%{
    auto* db_val = static_cast<MatchyDB*>(db->AsOpaqueVal());
    if (!db_val) {
        zeek::reporter->Warning("Invalid Matchy database handle");
        return zeek::make_intrusive<zeek::StringVal>("");
    }
    
    matchy::matchy_t* db_handle = db_val->GetHandle();
    if (!db_handle) {
        zeek::reporter->Warning("Matchy database handle is closed");
        return zeek::make_intrusive<zeek::StringVal>("");
    }
    
    const char* query_str = query->CheckString();
    matchy_result_t result = matchy_query(db_handle, query_str);
    
    if (result.found) {
        char* json = matchy_result_to_json(&result);
        if (json) {
            auto ret = zeek::make_intrusive<zeek::StringVal>(json);
            matchy_free_string(json);
            matchy_free_result(&result);
            return ret;
        }
        matchy_free_result(&result);
    }
    
    return zeek::make_intrusive<zeek::StringVal>("");
%}

## Query database by IP address. Returns JSON string with results.
##
## db: Database handle from load_database()
## ip: IP address to query
##
## Returns: JSON string with match data, or empty string if no match
function query_ip%(db: opaque of MatchyDB, ip: addr%): string
%{
    auto* db_val = static_cast<MatchyDB*>(db->AsOpaqueVal());
    if (!db_val) {
        zeek::reporter->Warning("Invalid Matchy database handle");
        return zeek::make_intrusive<zeek::StringVal>("");
    }
    
    matchy::matchy_t* db_handle = db_val->GetHandle();
    if (!db_handle) {
        zeek::reporter->Warning("Matchy database handle is closed");
        return zeek::make_intrusive<zeek::StringVal>("");
    }
    
    // Convert Zeek addr to string
    std::string addr_cpp = ip->AsAddr().AsString();
    
    matchy_result_t result = matchy_query(db_handle, addr_cpp.c_str());
    
    if (result.found) {
        char* json = matchy_result_to_json(&result);
        if (json) {
            auto ret = zeek::make_intrusive<zeek::StringVal>(json);
            matchy_free_string(json);
            matchy_free_result(&result);
            return ret;
        }
        matchy_free_result(&result);
    }
    
    return zeek::make_intrusive<zeek::StringVal>("");
%}
