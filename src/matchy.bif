module Matchy;

%%{
#include <matchy/matchy.h>
#include <zeek/Val.h>
#include <map>
#include <string>

using namespace matchy;

// Global database handle storage
static std::map<std::string, matchy_t*> databases;
%%}

## Load a Matchy database from file. Returns true on success, false on failure.
## Database is identified by a unique name and can be queried using that name.
##
## db_name: Unique identifier for this database instance
## filename: Path to the .mxy database file
##
## Returns: true if database loaded successfully, false otherwise
function load_database%(db_name: string, filename: string%): bool
%{
    const char* name = db_name->CheckString();
    const char* path = filename->CheckString();
    
    // Check if database already exists
    if (databases.find(name) != databases.end()) {
        zeek::reporter->Warning("Matchy database '%s' already loaded", name);
        return zeek::val_mgr->False();
    }
    
    // Open database
    matchy_t* db = matchy_open(path);
    if (!db) {
        zeek::reporter->Warning("Failed to open Matchy database: %s", path);
        return zeek::val_mgr->False();
    }
    
    databases[name] = db;
    return zeek::val_mgr->True();
%}

## Query database by string (exact match or pattern). Returns JSON string with results.
##
## db_name: Name of the loaded database
## query: String to query (domain name, exact string, or pattern)
##
## Returns: JSON string with match data, or empty string if no match
function query_string%(db_name: string, query: string%): string
%{
    const char* name = db_name->CheckString();
    const char* query_str = query->CheckString();
    
    auto it = databases.find(name);
    if (it == databases.end()) {
        zeek::reporter->Warning("Matchy database '%s' not found", name);
        return zeek::make_intrusive<zeek::StringVal>("");
    }
    
    matchy_result_t result = matchy_query(it->second, query_str);
    
    if (result.found) {
        char* json = matchy_result_to_json(&result);
        if (json) {
            auto ret = zeek::make_intrusive<zeek::StringVal>(json);
            matchy_free_string(json);
            matchy_free_result(&result);
            return ret;
        }
        matchy_free_result(&result);
    }
    
    return zeek::make_intrusive<zeek::StringVal>("");
%}

## Query database by IP address. Returns JSON string with results.
##
## db_name: Name of the loaded database
## ip: IP address to query
##
## Returns: JSON string with match data, or empty string if no match
function query_ip%(db_name: string, ip: addr%): string
%{
    const char* name = db_name->CheckString();
    
    auto it = databases.find(name);
    if (it == databases.end()) {
        zeek::reporter->Warning("Matchy database '%s' not found", name);
        return zeek::make_intrusive<zeek::StringVal>("");
    }
    
    // Convert Zeek addr to string
    std::string addr_cpp = ip->AsAddr().AsString();
    
    matchy_result_t result = matchy_query(it->second, addr_cpp.c_str());
    
    if (result.found) {
        char* json = matchy_result_to_json(&result);
        if (json) {
            auto ret = zeek::make_intrusive<zeek::StringVal>(json);
            matchy_free_string(json);
            matchy_free_result(&result);
            return ret;
        }
        matchy_free_result(&result);
    }
    
    return zeek::make_intrusive<zeek::StringVal>("");
%}

## Unload a database and free its resources. Returns true on success.
##
## db_name: Name of the database to unload
##
## Returns: true if database unloaded successfully, false if not found
function unload_database%(db_name: string%): bool
%{
    const char* name = db_name->CheckString();
    
    auto it = databases.find(name);
    if (it == databases.end()) {
        zeek::reporter->Warning("Matchy database '%s' not found", name);
        return zeek::val_mgr->False();
    }
    
    matchy_close(it->second);
    databases.erase(it);
    return zeek::val_mgr->True();
%}
